# hmpl

The main object of the entire module. It includes all the properties and methods that help you work with the server.

This object does not need to be imported. It is assigned to the entire document, so you can immediately use it in your code.

## compile

The `compile` function takes as its first argument a string that represents the extended HTML syntax with the request objects passed to it (more simply, the hmpl syntax), and as its second argument it takes the [HMPLCompileOptions](/types.md#hmplcompileoptions) options object.

```javascript
const templateFn = hmpl.compile(
  `{ 
     {
       "src":"/api/test" 
     } 
   }`,
  {
    memo: true,
    autoBody: {
      formData: true
    },
    allowedContentTypes: ["text/html"],
    disallowedTags: ["script"],
    sanitize: false
  }
);
```

### Options

Sets options for all request objects coming from the [HMPLTemplateFunction](/types.md#hmpltemplatefunction) generated by the current `compile` function.

#### [memo](/request.md#memo)

#### [autoBody](/request.md#autobody)

#### [allowedContentTypes](/request.md#allowedcontenttypes)

#### [disallowedTags](/request.md#disallowedtags)

#### [sanitize](/request.md#sanitize)

Each option corresponds to the one in [request](/request.md). If an option is specified, but the request specifies the same one with a different value, then the one in the request will override it.

### RequestInit

`compile` returns a [template function](/types.md#hmpltemplatefunction) that takes as arguments an object of type [HMPLRequestInit](/types.md#hmplrequestinit), which initializes a dictionary with request options, or an array of objects of type [HMPLIdentificationRequestInit](/types.md#hmplidentificationrequestinit), which is essentially the same dictionary, but with an `id` for binding to specific requests or the [HMPLRequestInitFunction](#requestinit-function) function.

```javascript
const elementObj = templateFn({
  mode: "cors",
  cache: "no-cache",
  credentials: "same-origin",
  headers: {
    "Content-Type": "text/html"
  },
  redirect: "follow",
  get: (prop, value) => {},
  referrerPolicy: "no-referrer",
  body: JSON.stringify(data),
  signal: new AbortController().signal,
  integrity: "...",
  window: null,
  refferer: "about:client"
});
```

### Identification RequestInit

```javascript
const elementObj = templateFn([
  {
    id: "1",
    value: {
      mode: "cors",
      cache: "no-cache",
      credentials: "same-origin",
      headers: {
        "Content-Type": "text/html"
      },
      redirect: "follow",
      get: (prop, value) => {},
      referrerPolicy: "no-referrer",
      body: JSON.stringify(data)
    }
  }
]);
```

> It is worth considering that if an array is passed, then if the `initId` property is not specified, the request will be sent without a options object

The `id` value of each options identification object is unique. The property value is a `string` or a `number`.

The function returns an object that depends on the template string to determine the number of properties. If there are 2 or more request objects in the template string, then the `requests` property is added, which has the value of an array of objects for each request object. Their properties are copied as if there was one request object in the template string.

```javascript
const templateFn = hmpl.compile(
  `{ 
     {
       "src":"/api/test" 
     } 
   }`
);
const elementObj = templateFn();
```

result:

```javascript
{
  status: 200,
  response: template
}
```

or

```javascript
const templateFn = hmpl.compile(
  `<div>
   {
     {
       "src":"/api/test"
     }
   }
   {
     {
       "src":"/api/test"
     }
   }
</div>`
);
const elementObj = templateFn();
```

result:

```javascript
{
  response: div,
  requests: [
    {
      status: 200,
      response: template,
    },
    {
      status: 200,
      response: template,
    },
  ],
};
```

The `response` that is generated for the `element` will not contain a `template` tag, but an array with `ChildNode`'s, because these nodes have already been rendered into the DOM from the template string.

Values are dynamically assigned to the object depending on the server response.

> The status changes depending on the server response. But, the most important thing is that it is not assigned several times if it is the same. When working with `Proxy` or `Object.defineProperty` or `get` or something like that, this will not give the object unnecessary updates!

### RequestInit function

In order to work with the [context](#concept-of-context), the new version introduced the [HMPLRequestInitFunction](/types.md#hmplrequestinitfunction) function. It takes as an argument the [HMPLInstanceContext](/types.md#hmplinstancecontext) object. Returns [HMPLRequestInit](/types.md#hmplrequestinit).

```javascript
const elementObj = templateFn(({
  request: { event }
})=>{
  {
      mode: "cors",
      cache: "no-cache",
      credentials: "same-origin",
      headers: {
        "Content-Type": "text/html",
      },
      redirect: "follow",
      get: (prop, value) => {},
      referrerPolicy: "no-referrer",
      body: new FormatData(event.target, event.submitter),
    }
});
```

Also, the function value can be used as a `value` for the identification RequestInit.

#### get

The get property takes the value of a function that fires every time one of the properties is updated.

```javascript
const elementObj = templateFn({
  get: (prop, value, requestObject) => {
    switch (prop) {
      case "response":
        if (!requestObject) console.log(requestObject);
        console.log("Response:");
        console.log(value);
        break;
      case "status":
        console.log("Status:");
        console.log(value);
        break;
    }
  }
});
```

It is worth noting that the `requests` property is not called when the value changes, because the function is called when the values ​​in this property change only for array elements. This is a debatable thing, but it may not be necessary to call this function when a specific property of an object is called.

Also, to work with `async` `await` you can use a similar construct that uses a vanilla `Promise` object:

```javascript
const val = await new Promise((res, rej) => {
  templateFn({
    get: (prop, value, requestObject) => {
      switch (prop) {
        case "response":
          if (!value) return;
          res(value);
          break;
      }
    }
  });
});
```

This is described in more detail in the blog in [this article](https://blog.hmpl-lang.dev/blog/2024/11/25/asynchronicity-async-await-support-when-working-with-hmpl.html).

## stringify

This function accepts an object of type [HMPLRequestInfo](/types.md#hmplrequestinfo) with request data and returns a string request object.

```javascript
const request = hmpl.stringify({
  src: "/api/test"
});
const templateFn = hmpl.compile(`{${request}}`);
```

It is based on `JSON.stringify`.

## Concept of context

In hmpl, the concept of context is introduced for transferring data in instances. In itself, it represents a certain environment with data from which you can get, but not yet write, a value.

So far, one context has been introduced - this is the instance context. Its type is [HMPLInstanceContext](/types.md#hmplinstancecontext). It includes the request context [HMPLRequestContext](/types.md#hmplrequestcontext), which is generated when sending a request to the server.

```hmpl
<div>
  <button id="getHTML">Get HTML!</button>
  {{ "src":"/api/getHTML", method:"POST", after:"click:#getHTML" }}
</div>
```

```javascript
/**
 * ctx = {
 *   request: {
 *     event: PointerEvent,
 *   },
 * };
 */

const initFn = (ctx) => {
  const event = ctx.request.event;
  const text = event.target.textContent;
  return {
    body: text
  };
};
const elementObj = templateFn(initFn);
```

In this example, thanks to the context, we get an event that is triggered when the `button` is clicked. This is a very useful feature, because for things like `FormData`, or `value` for `input`, you can now generate a custom [HMPLRequestInit](/types.md#hmplrequestinit).
